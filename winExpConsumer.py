import game
import re

# some regex helpers for parsing the event information
modRe = re.compile(r"(/|\.)([A-Za-z0-9\-])")
foutRe = re.compile(r"([0-9]+)(\(([1-3]|B)\))?([0-9]+)?")
def fielderToBase(putoutStr):
	# Maps the fielder to the typical baserunner that they get out. For
	# example the second basemen ("4") typically gets the runner coming from
	# first base "1" out, so 4: 1.
	fmap = {1: 0, 2: 3, 3: 0, 4: 1, 5: 2, 6: 1}
	return fmap[int(putoutStr[-1])]

# TODO: I've got the layout wrong here. This should be in the Game
# class. The Game class should handle event parsing. The GameConsumer
# should use the fields generated by the Game class to generate
# statistics.
class GameConsumer(object):

	def __init__(self):
		self.reset()

	def reset(self):
		self.gameObj = None # Handled by the process task
		self.state = { "vR" : 0, "hR" : 0, \
			"i" : 0, "o" : 0, \
			"1b" : None, "2b" : None, "3b" : None }

	def buildState(self, eventStr):
		foutMatch = foutRe.match(eventStr)
		newState = self.state
		if foutMatch == None:
			# TODO: process other formats
			return newState
		else:
			# print eventStr + "->",
			# Handle outs that were fielded
			# TODO: Make the data regarding which fielders are involved
			# available to consumers. It's not necessary for WinExp but it is
			# nice for other statistics.
			for match in foutRe.finditer(eventStr):
				if match.group(4) != None:
					# This is a double play
					bases = [int(match.group(3)), fielderToBase(match.group(4))]
				elif match.group(3) != None:
					# Putout with the base specified
					bases = [int(match.group(3))]
				elif len(match.group(1)) == 1:
					# Fly ball out - always at first base
					bases = [1]
				else:
					# Regular put-out, nothing fancy
					bases = [fielderToBase(match.group(1)[-1])]

			for base in bases:
				newState["o"] += 1
				if base > 0: newState["%db" % base] = None

			# print ",".join([str(base) for base in bases]),

			return newState

	def processPlay(self, record):
		eventStr = record["event"]
		match = modRe.search(eventStr)

		# Look for modifiers and use the beginning for the play type
		if match == None: playType = eventStr
		else: playType = eventStr[:match.start(0)] 

		# Read in all the modifiers and base runners
		mods = []
		movs = []
		while match != None:
			if match.group(1) == "/":
				mods += [match.group(2)]
			elif match.group(1) == ".":
				movs += [match.group(2)]
			match = modRe.search(eventStr, match.end(0))

		# Figure out the new state based on the play type
		self.state = self.buildState(playType)


	def process(self, gameObj):
		self.reset()
		self.gameObj = gameObj

		print gameObj.infos["date"],
		for record in gameObj.events:
			if record["key"] == "play":
				if record["inning"] != self.state["i"]:
					self.state["i"] = record["inning"]
					print "\n%d: " % record["inning"],
					print self.state,
				self.processPlay(record)
		print ""



